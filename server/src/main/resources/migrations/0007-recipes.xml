<?xml version="1.0" encoding="UTF-8"?>
<!--
    stocks is client-server program to manage a household's food stock
    Copyright (C) 2019  The stocks developers

    This file is part of the stocks program suite.

    stocks is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    stocks is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see https://www.gnu.org/licenses/.
-->
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd"
        context="production">

    <changeSet id="1" author="admin">
        <sql endDelimiter=";;">
            create or replace function bitemporal_primary_key() returns trigger
                language PLPGSQL
            as
            $$
            declare
                violating_row_count int;
            begin
                execute format(
                    'select count(*) '
                    'from %I as u1 '
                    'where u1.id is null '
                       'or 1 &lt; ( '
                        'select count(*) '
                        'from %I as u2 '
                        'where u1.id = u2.id '
                          'and u1.valid_time_start &lt; u2.valid_time_end '
                          'and u2.valid_time_start &lt; u1.valid_time_end '
                          'and u1.transaction_time_end = %L '
                          'and u2.transaction_time_end = %L '
                       ')',
                        tg_table_name, tg_table_name, 'infinity', 'infinity')
                    into violating_row_count;

                if violating_row_count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create or replace function contiguous_primary_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                execute format(
                    'select count(*) '
                    'from %I u1, '
                         '%I u2 '
                    'where u1.valid_time_end &lt; u2.valid_time_end '
                      'and u1.id = u2.id '
                      'and u1.transaction_time_end = %L '
                      'and u2.transaction_time_end = %L '
                      'and not exists( '
                            'select * '
                            'from %I u3 '
                            'where u3.id = u1.id '
                              'and u3.transaction_time_end = %L '
                              'and (((u3.valid_time_start &lt;= u1.valid_time_end) '
                                'and (u1.valid_time_end &lt; u3.valid_time_end)) '
                                'or ((u3.valid_time_start &lt; u2.valid_time_start) '
                                    'and '
                                    'u2.valid_time_start &lt;= u3.valid_time_end)) '
                      ')',
                        tg_table_name, tg_table_name, 'infinity', 'infinity', tg_table_name, 'infinity')
                    into count;

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            -- arg 0: Referring table
            -- arg 1: Referring column
            -- arg 2: Referred table
            create or replace function bitemporal_foreign_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                execute format(
                    'select * '
                    'from %I f '
                    'where f.transaction_time_end = %L '
                      'and ( '
                            'not exists( '
                                    'select * '
                                    'from %I p '
                                    'where f.%I = p.id '
                                      'and p.transaction_time_end = %L '
                                      'and p.valid_time_start &lt;= f.valid_time_start '
                                      'and f.valid_time_start &lt; p.valid_time_end '
                                ') '
                            'or not exists( '
                                'select * '
                                'from %I u '
                                'where f.%I = u.id '
                                  'and u.transaction_time_end = %L '
                                  'and u.valid_time_start &lt; f.valid_time_end '
                                  'and f.valid_time_end &lt;= u.valid_time_end '
                            ') '
                        ')',
                        tg_argv[0], 'infinity', tg_argv[2], tg_argv[1], 'infinity', tg_argv[2], tg_argv[1], 'infinity')
                    into count;

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            -- arg 0: Referring table
            create or replace function bitemporal_initiates_foreign_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                execute format(
                    'select * '
                    'from %I f '
                    'where f.transaction_time_end = %L '
                      'and ( '
                        'not exists( '
                                'select * '
                                'from user_device p '
                                'where f.initiates = p.id '
                                  'and p.transaction_time_end = %L '
                                  'and p.valid_time_start &lt;= f.transaction_time_start '
                                  'and f.transaction_time_start &lt; p.valid_time_end '
                            ') '
                        ')', tg_argv[0], 'infinity', 'infinity')
                into count;

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            -- arg 0: Referring table
            -- arg 1: Referring column
            -- arg 2: Referred table
            create or replace function current_to_bitemporal_foreign_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                execute format(
                    'select count(*) '
                    'from %I as f '
                    'where not exists( '
                            'select * '
                            'from %I as p '
                            'where p.id = f.%I '
                              'and p.valid_time_end = %L '
                              'and p.transaction_time_end = %L '
                        ')',
                    tg_argv[0], tg_argv[2], tg_argv[1], 'infinity', 'infinity')
                into count;

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            -- arg 0: Referring table
            -- arg 1: Referring column
            -- arg 2: Referred table
            create or replace function nullable_bitemporal_foreign_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                execute format(
                'select * '
                'from %I f '
                'where f.transaction_time_end = %L '
                  'and f.%I is not null '
                  'and ( '
                        'not exists( '
                                'select * '
                                'from %I p '
                                'where f.%I = p.id '
                                  'and p.transaction_time_end = %L '
                                  'and p.valid_time_start &lt;= f.valid_time_start '
                                  'and f.valid_time_start &lt; p.valid_time_end '
                            ') '
                        'or not exists( '
                            'select * '
                            'from %I p '
                            'where f.%I = p.id '
                              'and p.transaction_time_end = %L '
                              'and p.valid_time_start &lt; f.valid_time_end '
                              'and f.valid_time_end &lt;= p.valid_time_end '
                        ') '
                    ')', tg_argv[0], 'infinity', tg_argv[1], tg_argv[2],
                    tg_argv[1], 'infinity', tg_argv[2], tg_argv[1], 'infinity')
                    into count;

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            alter table "Food" rename to food;
            alter table "User" rename to "user";
            alter table "User_device" rename to user_device;
            alter table "Location" rename to location;
            alter table "Food_item" rename to food_item;
            alter table "EAN_number" rename to ean_number;
            alter table "Ticket" rename to ticket;

            alter table food rename column "ID" to id;
            alter table "user" rename column "ID" to id;
            alter table user_device rename column "ID" to id;
            alter table location rename column "ID" to id;
            alter table food_item rename column "ID" to id;
            alter table ean_number rename column "ID" to id;
            alter table ticket rename column "ID" to id;

            drop function user_bitemporal_primary_key cascade;
            create constraint trigger user_bitemporal_primary_key
                after insert or update or delete
                on "user"
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            drop function user_contiguous_primary_key cascade;
            create constraint trigger user_contiguous_primary_key
                after insert or update or delete
                on "user"
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();;

            drop function location_bitemporal_primary_key cascade;
            create constraint trigger location_bitemporal_primary_key
                after insert or update or delete
                on location
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            drop function location_contiguous_primary_key cascade;
            create constraint trigger location_contiguous_primary_key
                after insert or update or delete
                on location
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();;

            drop function food_bitemporal_primary_key cascade;
            create constraint trigger food_bitemporal_primary_key
                after insert or update or delete
                on food
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            drop function food_contiguous_primary_key cascade;
            create constraint trigger food_contiguous_primary_key
                after insert or update or delete
                on food
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();;

            drop function user_device_bitemporal_primary_key cascade;
            create constraint trigger user_device_bitemporal_primary_key
                after insert or update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            drop function user_device_contiguous_primary_key cascade;
            create constraint trigger user_device_contiguous_primary_key
                after insert or update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();;

            drop function food_item_bitemporal_primary_key cascade;
            create constraint trigger food_item_bitemporal_primary_key
                after insert or update or delete
                on food_item
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            drop function food_item_contiguous_primary_key cascade;
            create constraint trigger food_item_contiguous_primary_key
                after insert or update or delete
                on food_item
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();;

            drop function ean_number_bitemporal_primary_key cascade;
            create constraint trigger ean_number_bitemporal_primary_key
                after insert or update or delete
                on ean_number
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            drop function ean_number_contiguous_primary_key cascade;
            create constraint trigger ean_number_contiguous_primary_key
                after insert or update or delete
                on ean_number
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();;

            drop function ticket_belongs_device_ref_user_device cascade;;
            create constraint trigger ticket_belongs_device_ref_user_device
                after insert or update
                on ticket
                deferrable initially deferred
                for each row
            execute function current_to_bitemporal_foreign_key('ticket', 'belongs_device', 'user_device');;

            create constraint trigger ticket_belongs_device_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function current_to_bitemporal_foreign_key('ticket', 'belongs_device', 'user_device');;

            drop function user_device_belongs_to_ref_user cascade;;
            create constraint trigger user_device_belongs_to_ref_user
                after update or delete
                on "user"
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('user_device', 'belongs_to', 'user');;

            create constraint trigger user_device_belongs_to_ref_user
                after insert or update
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('user_device', 'belongs_to', 'user');;

            drop function ean_number_identifies_ref_food cascade;;
            create constraint trigger ean_number_identifies_ref_food
                after update or delete
                on food
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('ean_number', 'identifies', 'food');;

            create constraint trigger ean_number_identifies_ref_food
                after insert or update
                on ean_number
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('ean_number', 'identifies', 'food');;

            drop function food_item_buys_ref_user cascade;;
            create constraint trigger food_item_buys_ref_user
                after update or delete
                on "user"
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food_item', 'buys', 'user');;

            create constraint trigger food_item_buys_ref_user
                after insert or update
                on food_item
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food_item', 'buys', 'user');;

            drop function food_item_of_type_ref_food cascade;;
            create constraint trigger food_item_of_type_ref_food
                after update or delete
                on food
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food_item', 'of_type', 'food');;

            create constraint trigger food_item_of_type_ref_food
                after insert or update
                on food_item
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food_item', 'of_type', 'food');;

            drop function food_item_registers_ref_user_device cascade;;
            create constraint trigger food_item_registers_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food_item', 'registers', 'user_device');;

            create constraint trigger food_item_registers_ref_user_device
                after insert or update
                on food_item
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food_item', 'registers', 'user_device');;

            drop function food_item_stored_in_ref_location cascade;;
            create constraint trigger food_item_stored_in_ref_location
                after update or delete
                on location
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food_item', 'stored_in', 'location');;

            create constraint trigger food_item_stored_in_ref_location
                after insert or update
                on food_item
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food_item', 'stored_in', 'location');;

            drop function food_location_ref_location cascade;;
            create constraint trigger food_location_ref_location
                after update or delete
                on location
                deferrable initially deferred
                for each row
            execute function nullable_bitemporal_foreign_key('food', 'location', 'location');;

            create constraint trigger food_location_ref_location
                after insert or update
                on food
                deferrable initially deferred
                for each row
            execute function nullable_bitemporal_foreign_key('food', 'location', 'location');;

            drop function user_initiates_ref_user_device cascade;;
            create constraint trigger user_initiates_ref_user_device
                after insert or update
                on "user"
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('user');

            create constraint trigger user_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('user');

            drop function food_initiates_ref_user_device cascade;;
            create constraint trigger food_initiates_ref_user_device
                after insert or update
                on food
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('food');

            create constraint trigger food_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('food');

            drop function food_item_initiates_ref_user_device cascade;;
            create constraint trigger food_item_initiates_ref_user_device
                after insert or update
                on food_item
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('food_item');

            create constraint trigger food_item_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('food_item');

            drop function location_initiates_ref_user_device cascade;;
            create constraint trigger location_initiates_ref_user_device
                after insert or update
                on location
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('location');

            create constraint trigger location_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('location');

            drop function ean_number_initiates_ref_user_device cascade;;
            create constraint trigger ean_number_initiates_ref_user_device
                after insert or update
                on ean_number
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('ean_number');

            create constraint trigger ean_number_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('ean_number');

            drop function user_device_initiates_ref_user_device cascade;;
            create constraint trigger user_device_initiates_ref_user_device
                after insert or update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('user_device');

        </sql>
    </changeSet>
    <changeSet id="2" author="admin">
        <sql>
            create table recipe_product (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                amount int not null,
                product int not null,
                recipe int not null,
                unit int not null,
                initiates int not null
            );

            create index recipe_product_pkey on recipe_product (id);

            create index recipe_product_current
            on recipe_product (id asc, valid_time_start asc, valid_time_end asc)
            where transaction_time_end = 'infinity';

            create constraint trigger "recipe_product_bitemporal_primary_key"
                after insert or update or delete
                on recipe_product
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            create constraint trigger "recipe_product_contiguous_primary_key"
                after insert or update or delete
                on recipe_product
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();
        </sql>
        <rollback>
            drop table recipe_product;
        </rollback>
    </changeSet>
    <changeSet id="3" author="admin">
        <sql>
            create table recipe_ingredient (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                amount int not null,
                ingredient int not null,
                recipe int not null,
                unit int not null,
                initiates int not null
            );

            create index recipe_ingredient_pkey on recipe_ingredient (id);

            create index recipe_ingredient_current
            on recipe_ingredient (id asc, valid_time_start asc, valid_time_end asc)
            where transaction_time_end = 'infinity';

            create constraint trigger "recipe_ingredient_bitemporal_primary_key"
                after insert or update or delete
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            create constraint trigger "recipe_ingredient_contiguous_primary_key"
                after insert or update or delete
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();
        </sql>
        <rollback>
            drop table recipe_ingredient;
        </rollback>
    </changeSet>
    <changeSet id="4" author="admin">
        <sql>
            create table scaled_unit (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                scale numeric not null,
                unit int not null,
                initiates int not null
            );

            create index scaled_unit_pkey on scaled_unit (id);

            create index scaled_unit_current
            on scaled_unit (id asc, valid_time_start asc, valid_time_end asc)
            where transaction_time_end = 'infinity';

            create constraint trigger "scaled_unit_bitemporal_primary_key"
                after insert or update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            create constraint trigger "scaled_unit_contiguous_primary_key"
                after insert or update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();
        </sql>
        <rollback>
            drop table scaled_unit;
        </rollback>
    </changeSet>
    <changeSet id="5" author="admin">
        <sql>
            create table recipe (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                name text not null,
                instructions text not null,
                duration interval not null,
                initiates int not null
            );

            create index recipe_pkey on recipe (id);

            create index recipe_current
            on recipe (id asc, valid_time_start asc, valid_time_end asc)
            where transaction_time_end = 'infinity';

            create constraint trigger "recipe_bitemporal_primary_key"
                after insert or update or delete
                on recipe
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            create constraint trigger "recipe_contiguous_primary_key"
                after insert or update or delete
                on recipe
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();
        </sql>
        <rollback>
            drop table recipe;
        </rollback>
    </changeSet>
    <changeSet id="6" author="admin">
        <sql>
            create table unit (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                name text not null,
                abbreviation text not null,
                initiates int not null
            );

            create index unit_pkey on unit (id);

            create index unit_current
            on unit (id asc, valid_time_start asc, valid_time_end asc)
            where transaction_time_end = 'infinity';

            create constraint trigger "unit_bitemporal_primary_key"
                after insert or update or delete
                on unit
                deferrable initially deferred
                for each row
            execute function bitemporal_primary_key();

            create constraint trigger "unit_contiguous_primary_key"
                after insert or update or delete
                on unit
                deferrable initially deferred
                for each row
            execute function contiguous_primary_key();
        </sql>
        <rollback>
            drop table unit;
        </rollback>
    </changeSet>
    <changeSet id="7" author="admin">
        <sql>
            create constraint trigger recipe_product_product_ref_food
                after insert or update
                on recipe_product
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_product', 'product', 'food');

            create constraint trigger recipe_product_product_ref_food
                after update or delete
                on food
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_product', 'product', 'food');
        </sql>
        <rollback>
            drop trigger recipe_product_product_ref_food on recipe_product;
            drop trigger recipe_product_product_ref_food on food;
        </rollback>
    </changeSet>
    <changeSet id="8" author="admin">
        <sql>
            create constraint trigger recipe_product_unit_ref_scaled_unit
                after insert or update
                on recipe_product
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_product', 'unit', 'scaled_unit');

            create constraint trigger recipe_product_unit_ref_scaled_unit
                after update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_product', 'unit', 'scaled_unit');
        </sql>
        <rollback>
            drop trigger recipe_product_unit_ref_scaled_unit on recipe_product;
            drop trigger recipe_product_unit_ref_scaled_unit on scaled_unit;
        </rollback>
    </changeSet>
    <changeSet id="9" author="admin">
        <sql>
            create constraint trigger recipe_product_recipe_ref_recipe
                after insert or update
                on recipe_product
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_product', 'recipe', 'recipe');

            create constraint trigger recipe_product_recipe_ref_recipe
                after update or delete
                on recipe
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_product', 'recipe', 'recipe');
        </sql>
        <rollback>
            drop trigger recipe_product_recipe_ref_recipe on recipe_product;
            drop trigger recipe_product_recipe_ref_recipe on recipe;
        </rollback>
    </changeSet>
    <changeSet id="10" author="admin">
        <sql>
            create constraint trigger recipe_product_initiates_ref_user_device
                after insert or update
                on recipe_product
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('recipe_product');

            create constraint trigger recipe_product_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('recipe_product');
        </sql>
        <rollback>
            drop trigger recipe_product_initiates_ref_user_device on recipe_product;
            drop trigger recipe_product_initiates_ref_user_device on user_device;
        </rollback>
    </changeSet>
    <changeSet id="11" author="admin">
        <sql>
            create constraint trigger recipe_ingredient_ingredient_ref_food
                after insert or update
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_ingredient', 'ingredient', 'food');

            create constraint trigger recipe_ingredient_ingredient_ref_food
                after update or delete
                on food
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_ingredient', 'ingredient', 'food');
        </sql>
        <rollback>
            drop trigger recipe_ingredient_ingredient_ref_food on recipe_ingredient;
            drop trigger recipe_ingredient_ingredient_ref_food on food;
        </rollback>
    </changeSet>
    <changeSet id="12" author="admin">
        <sql>
            create constraint trigger recipe_ingredient_unit_ref_scaled_unit
                after insert or update
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_ingredient', 'unit', 'scaled_unit');

            create constraint trigger recipe_ingredient_unit_ref_scaled_unit
                after update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_ingredient', 'unit', 'scaled_unit');
        </sql>
        <rollback>
            drop trigger recipe_ingredient_unit_ref_scaled_unit on recipe_ingredient;
            drop trigger recipe_ingredient_unit_ref_scaled_unit on scaled_unit;
        </rollback>
    </changeSet>
    <changeSet id="13" author="admin">
        <sql>
            create constraint trigger recipe_ingredient_recipe_ref_recipe
                after insert or update
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_ingredient', 'recipe', 'recipe');

            create constraint trigger recipe_ingredient_recipe_ref_recipe
                after update or delete
                on recipe
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('recipe_ingredient', 'recipe', 'recipe');
        </sql>
        <rollback>
            drop trigger recipe_ingredient_recipe_ref_recipe on recipe_ingredient;
            drop trigger recipe_ingredient_recipe_ref_recipe on recipe;
        </rollback>
    </changeSet>
    <changeSet id="14" author="admin">
        <sql>
            create constraint trigger recipe_ingredient_initiates_ref_user_device
                after insert or update
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('recipe_ingredient');

            create constraint trigger recipe_ingredient_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('recipe_ingredient');
        </sql>
        <rollback>
            drop trigger recipe_ingredient_initiates_ref_user_device on recipe_ingredient;
            drop trigger recipe_ingredient_initiates_ref_user_device on user_device;
        </rollback>
    </changeSet>
    <changeSet id="15" author="admin">
        <sql>
            create constraint trigger scaled_unit_unit_ref_unit
                after insert or update
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('scaled_unit', 'unit', 'unit');

            create constraint trigger scaled_unit_unit_ref_unit
                after update or delete
                on unit
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('scaled_unit', 'unit', 'unit');
        </sql>
        <rollback>
            drop trigger scaled_unit_unit_ref_unit on scaled_unit;
            drop trigger scaled_unit_unit_ref_unit on unit;
        </rollback>
    </changeSet>
    <changeSet id="16" author="admin">
        <sql>
            create constraint trigger scaled_unit_initiates_ref_user_device
                after insert or update
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('scaled_unit');

            create constraint trigger scaled_unit_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('scaled_unit');
        </sql>
        <rollback>
            drop trigger scaled_unit_initiates_ref_user_device on scaled_unit;
            drop trigger scaled_unit_initiates_ref_user_device on user_device;
        </rollback>
    </changeSet>
    <changeSet id="17" author="admin">
        <sql>
            create constraint trigger recipe_initiates_ref_user_device
                after insert or update
                on recipe
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('recipe');

            create constraint trigger recipe_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('recipe');
        </sql>
        <rollback>
            drop trigger recipe_initiates_ref_user_device on recipe;
            drop trigger recipe_initiates_ref_user_device on user_device;
        </rollback>
    </changeSet>
    <changeSet id="18" author="admin">
        <sql>
            create constraint trigger unit_initiates_ref_user_device
                after insert or update
                on unit
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('unit');

            create constraint trigger unit_initiates_ref_user_device
                after update or delete
                on user_device
                deferrable initially deferred
                for each row
            execute function bitemporal_initiates_foreign_key('unit');
        </sql>
        <rollback>
            drop trigger unit_initiates_ref_user_device on unit;
            drop trigger unit_initiates_ref_user_device on user_device;
        </rollback>
    </changeSet>
    <changeSet id="19" author="admin">
        <sql endDelimiter=";;">
            create or replace function create_initial_user() returns void
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from user_device;

                if count != 0 then
                    return;
                end if;

                insert into "user" (name, initiates)
                values ('Default', 0);

                insert into user_device (name, belongs_to, initiates)
                values ('Default', lastval(), 0);

                update "user"
                set initiates = (select min(id) from user_device);

                update user_device
                set initiates = (select min(id) from user_device);

                insert into ticket (ticket, belongs_device)
                select '0000', id
                from user_device;
            end;
            $$;;

            select create_initial_user();;

            drop function create_initial_user cascade;;
        </sql>
        <rollback/>
    </changeSet>
    <changeSet id="20" author="admin">
        <sql>
            insert into unit (name, abbreviation, initiates, valid_time_start, transaction_time_start)
            select 'Default', 'default', min(id), min(valid_time_start), min(transaction_time_start)
            from user_device
            where valid_time_start &lt;= current_timestamp
            and current_timestamp &lt; valid_time_end
            and transaction_time_end = 'infinity';

            insert into scaled_unit (scale, unit, initiates, valid_time_start, transaction_time_start)
            select 1, lastval(), min(id), min(valid_time_start), min(transaction_time_start)
            from user_device
            where valid_time_start &lt;= current_timestamp
            and current_timestamp &lt; valid_time_end
            and transaction_time_end = 'infinity';
        </sql>
        <rollback/>
    </changeSet>
    <changeSet id="21" author="admin">
        <sql>
            alter table food add column store_unit int;
            update food set store_unit = (select min(id) from scaled_unit);
        </sql>
        <rollback>
            alter table food drop column store_unit;
        </rollback>
    </changeSet>
    <changeSet id="22" author="admin">
        <sql>
            alter table food alter column store_unit set not null;
        </sql>
        <rollback>
            alter table food alter column store_unit drop not null;
        </rollback>
    </changeSet>
    <changeSet id="23" author="admin">
        <sql>
            create constraint trigger food_store_unit_ref_scaled_unit
                after insert or update
                on food
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food', 'store_unit', 'scaled_unit');

            create constraint trigger food_store_unit_ref_scaled_unit
                after update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function bitemporal_foreign_key('food', 'store_unit', 'scaled_unit');
        </sql>
        <rollback>
            drop trigger food_store_unit_ref_scaled_unit on food;
            drop trigger food_store_unit_ref_scaled_unit on scaled_unit;
        </rollback>
    </changeSet>
    <changeSet id="24" author="admin">
        <sql>
            create or replace view updates (id, table_name, last_update) as
            select 1,
                   'Location',
                   coalesce(max(transaction_time_start), current_timestamp)
            from location
            union
            select 2,
                   'User',
                   coalesce(max(transaction_time_start), current_timestamp)
            from "user"
            union
            select 3,
                   'User_device',
                   coalesce(max(transaction_time_start), current_timestamp)
            from user_device
            union
            select 4,
                   'Food',
                   coalesce(max(transaction_time_start), current_timestamp)
            from food
            union
            select 5,
                   'Food_item',
                   coalesce(max(transaction_time_start), current_timestamp)
            from food_item
            union
            select 6,
                   'EAN_number',
                   coalesce(max(transaction_time_start), current_timestamp)
            from ean_number
            union
            select 7,
                   'recipe_product',
                   coalesce(max(transaction_time_start), current_timestamp)
            from recipe_product
            union
            select 8,
                   'recipe_ingredient',
                   coalesce(max(transaction_time_start), current_timestamp)
            from recipe_ingredient
            union
            select 9,
                   'scaled_unit',
                   coalesce(max(transaction_time_start), current_timestamp)
            from scaled_unit
            union
            select 10,
                   'recipe',
                   coalesce(max(transaction_time_start), current_timestamp)
            from recipe
            union
            select 11,
                   'unit',
                   coalesce(max(transaction_time_start), current_timestamp)
            from unit;
        </sql>
    </changeSet>
</databaseChangeLog>

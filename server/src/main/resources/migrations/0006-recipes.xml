<?xml version="1.0" encoding="UTF-8"?>
<!--
    stocks is client-server program to manage a household's food stock
    Copyright (C) 2019  The stocks developers

    This file is part of the stocks program suite.

    stocks is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    stocks is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see https://www.gnu.org/licenses/.
-->
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd"
        context="production">

    <changeSet id="1" author="admin">
        <sql endDelimiter=";;">
            create table recipe_product (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                amount int not null,
                product int not null,
                recipe int not null,
                unit int not null,
                initiates int not null
            );;

            create index recipe_product_pkey on recipe_product (id);

            create or replace function recipe_product_bitemporal_primary_key() returns trigger
                language PLPGSQL
            as
            $$
            declare
                violating_row_count int;
            begin
                select count(*)
                into violating_row_count
                from recipe_product as u1
                where u1.id is null
                   or 1 &lt; (
                    select count(*)
                    from recipe_product as u2
                    where u1.id = u2.id
                      and u1.valid_time_start &lt; u2.valid_time_end
                      and u2.valid_time_start &lt; u1.valid_time_end
                      and u1.transaction_time_end = 'infinity'
                      and u2.transaction_time_end = 'infinity');
                if violating_row_count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "recipe_product_bitemporal_primary_key"
                after insert or update or delete
                on recipe_product
                deferrable initially deferred
                for each row
            execute function recipe_product_bitemporal_primary_key();;

            create or replace function recipe_product_contiguous_primary_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_product u1,
                     recipe_product u2
                where u1.valid_time_end &lt; u2.valid_time_end
                  and u1.id = u2.id
                  and u1.transaction_time_end = 'infinity'
                  and u2.transaction_time_end = 'infinity'
                  and not exists(
                        select *
                        from recipe_product u3
                        where u3.id = u1.id
                          and u3.transaction_time_end = 'infinity'
                          and (((u3.valid_time_start &lt;= u1.valid_time_end)
                            and (u1.valid_time_end &lt; u3.valid_time_end))
                            or ((u3.valid_time_start &lt; u2.valid_time_start)
                                and
                                u2.valid_time_start &lt;= u3.valid_time_end))
                    );
                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "recipe_product_contiguous_primary_key"
                after insert or update or delete
                on recipe_product
                deferrable initially deferred
                for each row
            execute function recipe_product_contiguous_primary_key();;
        </sql>
        <rollback>
            drop function recipe_product_bitemporal_primary_key cascade;
            drop function recipe_product_contiguous_primary_key cascade;
            drop table recipe_product;
        </rollback>
    </changeSet>
    <changeSet id="2" author="admin">
        <sql endDelimiter=";;">
            create table recipe_ingredient (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                amount int not null,
                ingredient int not null,
                recipe int not null,
                unit int not null,
                initiates int not null
            );;

            create index recipe_ingredient_pkey on recipe_ingredient (id);

            create or replace function recipe_ingredient_bitemporal_primary_key() returns trigger
                language PLPGSQL
            as
            $$
            declare
                violating_row_count int;
            begin
                select count(*)
                into violating_row_count
                from recipe_ingredient as u1
                where u1.id is null
                   or 1 &lt; (
                    select count(*)
                    from recipe_ingredient as u2
                    where u1.id = u2.id
                      and u1.valid_time_start &lt; u2.valid_time_end
                      and u2.valid_time_start &lt; u1.valid_time_end
                      and u1.transaction_time_end = 'infinity'
                      and u2.transaction_time_end = 'infinity');
                if violating_row_count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "recipe_ingredient_bitemporal_primary_key"
                after insert or update or delete
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_bitemporal_primary_key();;

            create or replace function recipe_ingredient_contiguous_primary_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_ingredient u1,
                     recipe_ingredient u2
                where u1.valid_time_end &lt; u2.valid_time_end
                  and u1.id = u2.id
                  and u1.transaction_time_end = 'infinity'
                  and u2.transaction_time_end = 'infinity'
                  and not exists(
                        select *
                        from recipe_ingredient u3
                        where u3.id = u1.id
                          and u3.transaction_time_end = 'infinity'
                          and (((u3.valid_time_start &lt;= u1.valid_time_end)
                            and (u1.valid_time_end &lt; u3.valid_time_end))
                            or ((u3.valid_time_start &lt; u2.valid_time_start)
                                and
                                u2.valid_time_start &lt;= u3.valid_time_end))
                    );
                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "recipe_ingredient_contiguous_primary_key"
                after insert or update or delete
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_contiguous_primary_key();;
        </sql>
        <rollback>
            drop function recipe_ingredient_bitemporal_primary_key cascade;
            drop function recipe_ingredient_contiguous_primary_key cascade;
            drop table recipe_ingredient;
        </rollback>
    </changeSet>
    <changeSet id="3" author="admin">
        <sql endDelimiter=";;">
            create table scaled_unit (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                scale numeric not null,
                unit int not null,
                initiates int not null
            );;

            create index scaled_unit_pkey on scaled_unit (id);

            create or replace function scaled_unit_bitemporal_primary_key() returns trigger
                language PLPGSQL
            as
            $$
            declare
                violating_row_count int;
            begin
                select count(*)
                into violating_row_count
                from scaled_unit as u1
                where u1.id is null
                   or 1 &lt; (
                    select count(*)
                    from scaled_unit as u2
                    where u1.id = u2.id
                      and u1.valid_time_start &lt; u2.valid_time_end
                      and u2.valid_time_start &lt; u1.valid_time_end
                      and u1.transaction_time_end = 'infinity'
                      and u2.transaction_time_end = 'infinity');
                if violating_row_count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "scaled_unit_bitemporal_primary_key"
                after insert or update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function scaled_unit_bitemporal_primary_key();;

            create or replace function scaled_unit_contiguous_primary_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from scaled_unit u1,
                     scaled_unit u2
                where u1.valid_time_end &lt; u2.valid_time_end
                  and u1.id = u2.id
                  and u1.transaction_time_end = 'infinity'
                  and u2.transaction_time_end = 'infinity'
                  and not exists(
                        select *
                        from scaled_unit u3
                        where u3.id = u1.id
                          and u3.transaction_time_end = 'infinity'
                          and (((u3.valid_time_start &lt;= u1.valid_time_end)
                            and (u1.valid_time_end &lt; u3.valid_time_end))
                            or ((u3.valid_time_start &lt; u2.valid_time_start)
                                and
                                u2.valid_time_start &lt;= u3.valid_time_end))
                    );
                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "scaled_unit_contiguous_primary_key"
                after insert or update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function scaled_unit_contiguous_primary_key();;
        </sql>
        <rollback>
            drop function scaled_unit_bitemporal_primary_key cascade;
            drop function scaled_unit_contiguous_primary_key cascade;
            drop table scaled_unit;
        </rollback>
    </changeSet>
    <changeSet id="4" author="admin">
        <sql endDelimiter=";;">
            create table recipe (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                name text not null,
                instructions text not null,
                duration interval not null,
                initiates int not null
            );;

            create index recipe_pkey on recipe (id);

            create or replace function recipe_bitemporal_primary_key() returns trigger
                language PLPGSQL
            as
            $$
            declare
                violating_row_count int;
            begin
                select count(*)
                into violating_row_count
                from recipe as u1
                where u1.id is null
                   or 1 &lt; (
                    select count(*)
                    from recipe as u2
                    where u1.id = u2.id
                      and u1.valid_time_start &lt; u2.valid_time_end
                      and u2.valid_time_start &lt; u1.valid_time_end
                      and u1.transaction_time_end = 'infinity'
                      and u2.transaction_time_end = 'infinity');
                if violating_row_count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "recipe_bitemporal_primary_key"
                after insert or update or delete
                on recipe
                deferrable initially deferred
                for each row
            execute function recipe_bitemporal_primary_key();;

            create or replace function recipe_contiguous_primary_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe u1,
                     recipe u2
                where u1.valid_time_end &lt; u2.valid_time_end
                  and u1.id = u2.id
                  and u1.transaction_time_end = 'infinity'
                  and u2.transaction_time_end = 'infinity'
                  and not exists(
                        select *
                        from recipe u3
                        where u3.id = u1.id
                          and u3.transaction_time_end = 'infinity'
                          and (((u3.valid_time_start &lt;= u1.valid_time_end)
                            and (u1.valid_time_end &lt; u3.valid_time_end))
                            or ((u3.valid_time_start &lt; u2.valid_time_start)
                                and
                                u2.valid_time_start &lt;= u3.valid_time_end))
                    );
                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "recipe_contiguous_primary_key"
                after insert or update or delete
                on recipe
                deferrable initially deferred
                for each row
            execute function recipe_contiguous_primary_key();;
        </sql>
        <rollback>
            drop function recipe_bitemporal_primary_key cascade;
            drop function recipe_contiguous_primary_key cascade;
            drop table recipe;
        </rollback>
    </changeSet>
    <changeSet id="5" author="admin">
        <sql endDelimiter=";;">
            create table unit (
                id serial not null,
                version int not null default 0,
                valid_time_start timestamp(6) with time zone not null default current_timestamp,
                valid_time_end timestamp(6) with time zone not null default 'infinity',
                transaction_time_start timestamp(6) with time zone not null default current_timestamp,
                transaction_time_end timestamp (6) with time zone not null default 'infinity',
                name text not null,
                abbreviation text not null,
                initiates int not null
            );;

            create index unit_pkey on unit (id);

            create or replace function unit_bitemporal_primary_key() returns trigger
                language PLPGSQL
            as
            $$
            declare
                violating_row_count int;
            begin
                select count(*)
                into violating_row_count
                from unit as u1
                where u1.id is null
                   or 1 &lt; (
                    select count(*)
                    from unit as u2
                    where u1.id = u2.id
                      and u1.valid_time_start &lt; u2.valid_time_end
                      and u2.valid_time_start &lt; u1.valid_time_end
                      and u1.transaction_time_end = 'infinity'
                      and u2.transaction_time_end = 'infinity');
                if violating_row_count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "unit_bitemporal_primary_key"
                after insert or update or delete
                on unit
                deferrable initially deferred
                for each row
            execute function unit_bitemporal_primary_key();;

            create or replace function unit_contiguous_primary_key() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from unit u1,
                     unit u2
                where u1.valid_time_end &lt; u2.valid_time_end
                  and u1.id = u2.id
                  and u1.transaction_time_end = 'infinity'
                  and u2.transaction_time_end = 'infinity'
                  and not exists(
                        select *
                        from unit u3
                        where u3.id = u1.id
                          and u3.transaction_time_end = 'infinity'
                          and (((u3.valid_time_start &lt;= u1.valid_time_end)
                            and (u1.valid_time_end &lt; u3.valid_time_end))
                            or ((u3.valid_time_start &lt; u2.valid_time_start)
                                and
                                u2.valid_time_start &lt;= u3.valid_time_end))
                    );
                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger "unit_contiguous_primary_key"
                after insert or update or delete
                on unit
                deferrable initially deferred
                for each row
            execute function unit_contiguous_primary_key();;
        </sql>
        <rollback>
            drop function unit_bitemporal_primary_key cascade;
            drop function unit_contiguous_primary_key cascade;
            drop table unit;
        </rollback>
    </changeSet>
    <changeSet id="6" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_product_product_ref_food() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_product as f
                where not exists(
                        select *
                        from "Food" as p
                        where p."ID" = f.product
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;

            create constraint trigger recipe_product_product_ref_food
                after insert or update
                on recipe_product
                deferrable initially deferred
                for each row
            execute function recipe_product_product_ref_food();;

            create constraint trigger recipe_product_product_ref_food
                after update or delete
                on "Food"
                deferrable initially deferred
                for each row
            execute function recipe_product_product_ref_food();;
        </sql>
        <rollback>
            drop function recipe_product_product_ref_food cascade;
        </rollback>
    </changeSet>
    <changeSet id="7" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_product_unit_ref_scaled_unit() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_product as f
                where not exists(
                        select *
                        from scaled_unit as p
                        where p.id = f.unit
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger recipe_product_unit_ref_scaled_unit
                after insert or update
                on recipe_product
                deferrable initially deferred
                for each row
            execute function recipe_product_unit_ref_scaled_unit();;

            create constraint trigger recipe_product_unit_ref_scaled_unit
                after update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function recipe_product_unit_ref_scaled_unit();;
        </sql>
        <rollback>
            drop function recipe_product_unit_ref_scaled_unit cascade;
        </rollback>
    </changeSet>
    <changeSet id="8" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_product_recipe_ref_recipe() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_product as f
                where not exists(
                        select *
                        from recipe as p
                        where p.id = f.recipe
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger recipe_product_recipe_ref_recipe
                after insert or update
                on recipe_product
                deferrable initially deferred
                for each row
            execute function recipe_product_recipe_ref_recipe();;

            create constraint trigger recipe_product_recipe_ref_recipe
                after update or delete
                on recipe
                deferrable initially deferred
                for each row
            execute function recipe_product_recipe_ref_recipe();;
        </sql>
        <rollback>
            drop function recipe_product_recipe_ref_recipe cascade;
        </rollback>
    </changeSet>
    <changeSet id="9" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_product_initiates_ref_user_device() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_product as f
                where not exists(
                        select *
                        from "User_device" as p
                        where p."ID" = f.recipe
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger recipe_product_initiates_ref_user_device
                after insert or update
                on recipe_product
                deferrable initially deferred
                for each row
            execute function recipe_product_initiates_ref_user_device();;

            create constraint trigger recipe_product_initiates_ref_user_device
                after update or delete
                on "User_device"
                deferrable initially deferred
                for each row
            execute function recipe_product_initiates_ref_user_device();;
        </sql>
        <rollback>
            drop function recipe_product_initiates_ref_user_device cascade;
        </rollback>
    </changeSet>
    <changeSet id="10" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_ingredient_ingredient_ref_food() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_ingredient as f
                where not exists(
                        select *
                        from "Food" as p
                        where p."ID" = f.ingredient
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger recipe_ingredient_ingredient_ref_food
                after insert or update
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_ingredient_ref_food();;

            create constraint trigger recipe_ingredient_ingredient_ref_food
                after update or delete
                on "Food"
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_ingredient_ref_food();;
        </sql>
        <rollback>
            drop function recipe_ingredient_ingredient_ref_food cascade;
        </rollback>
    </changeSet>
    <changeSet id="11" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_ingredient_unit_ref_scaled_unit() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_ingredient as f
                where not exists(
                        select *
                        from scaled_unit as p
                        where p.id = f.unit
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger recipe_ingredient_unit_ref_scaled_unit
                after insert or update
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_unit_ref_scaled_unit();;

            create constraint trigger recipe_ingredient_unit_ref_scaled_unit
                after update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_unit_ref_scaled_unit();;
        </sql>
        <rollback>
            drop function recipe_ingredient_unit_ref_scaled_unit cascade;
        </rollback>
    </changeSet>
    <changeSet id="12" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_ingredient_recipe_ref_recipe() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_ingredient as f
                where not exists(
                        select *
                        from recipe as p
                        where p.id = f.recipe
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger recipe_ingredient_recipe_ref_recipe
                after insert or update
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_recipe_ref_recipe();;

            create constraint trigger recipe_ingredient_recipe_ref_recipe
                after update or delete
                on recipe
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_recipe_ref_recipe();;
        </sql>
        <rollback>
            drop function recipe_ingredient_recipe_ref_recipe cascade;
        </rollback>
    </changeSet>
    <changeSet id="13" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_ingredient_initiates_ref_user_device() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe_ingredient as f
                where not exists(
                        select *
                        from "User_device" as p
                        where p."ID" = f.initiates
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger recipe_ingredient_initiates_ref_user_device
                after insert or update
                on recipe_ingredient
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_initiates_ref_user_device();;

            create constraint trigger recipe_ingredient_initiates_ref_user_device
                after update or delete
                on "User_device"
                deferrable initially deferred
                for each row
            execute function recipe_ingredient_initiates_ref_user_device();;
        </sql>
        <rollback>
            drop function recipe_ingredient_initiates_ref_user_device cascade;
        </rollback>
    </changeSet>
    <changeSet id="14" author="admin">
        <sql endDelimiter=";;">
            create or replace function scaled_unit_unit_ref_unit() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from scaled_unit as f
                where not exists(
                        select *
                        from unit as p
                        where p.id = f.unit
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger scaled_unit_unit_ref_unit
                after insert or update
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function scaled_unit_unit_ref_unit();;

            create constraint trigger scaled_unit_unit_ref_unit
                after update or delete
                on unit
                deferrable initially deferred
                for each row
            execute function scaled_unit_unit_ref_unit();;
        </sql>
        <rollback>
            drop function scaled_unit_unit_ref_unit cascade;
        </rollback>
    </changeSet>
    <changeSet id="15" author="admin">
        <sql endDelimiter=";;">
            create or replace function scaled_unit_initiates_ref_user_device() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from scaled_unit as f
                where not exists(
                        select *
                        from "User_device" as p
                        where p."ID" = f.initiates
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger scaled_unit_initiates_ref_user_device
                after insert or update
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function scaled_unit_initiates_ref_user_device();;

            create constraint trigger scaled_unit_initiates_ref_user_device
                after update or delete
                on "User_device"
                deferrable initially deferred
                for each row
            execute function scaled_unit_initiates_ref_user_device();;
        </sql>
        <rollback>
            drop function scaled_unit_initiates_ref_user_device cascade;
        </rollback>
    </changeSet>
    <changeSet id="16" author="admin">
        <sql endDelimiter=";;">
            create or replace function recipe_initiates_ref_user_device() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from recipe as f
                where not exists(
                        select *
                        from "User_device" as p
                        where p."ID" = f.initiates
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger recipe_initiates_ref_user_device
                after insert or update
                on recipe
                deferrable initially deferred
                for each row
            execute function recipe_initiates_ref_user_device();;

            create constraint trigger recipe_initiates_ref_user_device
                after update or delete
                on "User_device"
                deferrable initially deferred
                for each row
            execute function recipe_initiates_ref_user_device();;
        </sql>
        <rollback>
            drop function recipe_initiates_ref_user_device cascade;
        </rollback>
    </changeSet>
    <changeSet id="17" author="admin">
        <sql endDelimiter=";;">
            create or replace function unit_initiates_ref_user_device() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from unit as f
                where not exists(
                        select *
                        from "User_device" as p
                        where p."ID" = f.initiates
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger unit_initiates_ref_user_device
                after insert or update
                on unit
                deferrable initially deferred
                for each row
            execute function unit_initiates_ref_user_device();;

            create constraint trigger unit_initiates_ref_user_device
                after update or delete
                on "User_device"
                deferrable initially deferred
                for each row
            execute function unit_initiates_ref_user_device();;
        </sql>
        <rollback>
            drop function unit_initiates_ref_user_device cascade;
        </rollback>
    </changeSet>
    <changeSet id="18" author="admin">
        <sql endDelimiter=";;">
            create or replace function create_initial_user() returns void
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from "User_device";

                if count != 0 then
                    return;
                end if;

                insert into "User" (name, initiates)
                values ('Default', 0);

                insert into "User_device" (name, belongs_to, initiates)
                values ('Default', lastval(), 0);

                update "User"
                set initiates = (select min("ID") from "User_device");

                update "User_device"
                set initiates = (select min("ID") from "User_device");

                insert into "Ticket" (ticket, belongs_device)
                select '0000', "ID"
                from "User_device";
            end;
            $$;;

            select create_initial_user();;
        </sql>
        <rollback/>
    </changeSet>
    <changeSet id="19" author="admin">
        <sql endDelimiter=";;">
            insert into unit (name, abbreviation, initiates, valid_time_start, transaction_time_start)
            select 'Default', 'default', min("ID"), min(valid_time_start), min(transaction_time_start)
            from "User_device"
            where valid_time_start &lt;= current_timestamp
            and current_timestamp &lt; valid_time_end
            and transaction_time_end = 'infinity';;

            insert into scaled_unit (scale, unit, initiates, valid_time_start, transaction_time_start)
            select 1, lastval(), min("ID"), min(valid_time_start), min(transaction_time_start)
            from "User_device"
            where valid_time_start &lt;= current_timestamp
            and current_timestamp &lt; valid_time_end
            and transaction_time_end = 'infinity';;
        </sql>
        <rollback/>
    </changeSet>
    <changeSet id="20" author="admin">
        <sql endDelimiter=";;">
            alter table "Food" add column store_unit int;;
            update "Food" set store_unit = (select min(id) from scaled_unit);
        </sql>
        <rollback>
            alter table "Food" drop column store_unit;
        </rollback>
    </changeSet>
    <changeSet id="21" author="admin">
        <sql endDelimiter=";;">
            alter table "Food" alter column store_unit set not null;;
        </sql>
        <rollback>
            alter table "Food" alter column store_unit drop not null;
        </rollback>
    </changeSet>
    <changeSet id="22" author="admin">
        <sql endDelimiter=";;">
            create or replace function food_store_unit_ref_scaled_unit() returns trigger
                language plpgsql
            as
            $$
            declare
                count int;
            begin
                select count(*)
                into count
                from "Food" as f
                where not exists(
                        select *
                        from scaled_unit as p
                        where p.id = f.store_unit
                          and p.valid_time_end = 'infinity'
                          and p.transaction_time_end = 'infinity'
                    );

                if count != 0 then
                    raise check_violation;
                end if;
                return new;
            end;
            $$;;
            create constraint trigger food_store_unit_ref_scaled_unit
                after insert or update
                on "Food"
                deferrable initially deferred
                for each row
            execute function food_store_unit_ref_scaled_unit();;

            create constraint trigger food_store_unit_ref_scaled_unit
                after update or delete
                on scaled_unit
                deferrable initially deferred
                for each row
            execute function food_store_unit_ref_scaled_unit();;
        </sql>
        <rollback>
            drop function food_store_unit_ref_scaled_unit cascade;
        </rollback>
    </changeSet>
</databaseChangeLog>
